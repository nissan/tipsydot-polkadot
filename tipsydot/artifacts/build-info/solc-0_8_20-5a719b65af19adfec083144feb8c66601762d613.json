{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-5a719b65af19adfec083144feb8c66601762d613",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/TipsyDotV3.sol": "project/contracts/TipsyDotV3.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/interfaces/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
      },
      "project/contracts/interfaces/IXcmRouter.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IXcmRouter {\n    function transferAssets(\n        address asset,\n        uint256 amount,\n        bytes calldata beneficiary,\n        uint32 destParaId,\n        uint64 weight\n    ) external;\n    \n    function transferAssetsWithMemo(\n        address asset,\n        uint256 amount,\n        bytes calldata beneficiary,\n        uint32 destParaId,\n        uint64 weight,\n        bytes calldata memo\n    ) external;\n}"
      },
      "project/contracts/TipsyDotV3.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IXcmRouter.sol\";\n\n/**\n * @title TipsyDot - Sustainable Cross-chain Crowdfunding on Polkadot\n * @notice Demonstrates Solidity smart contracts on Polkadot with XCM integration\n * @dev Takes 0.1% protocol fee to cover parachain coretime costs\n */\ncontract TipsyDotV3 {\n    struct Campaign {\n        string name;\n        string description;\n        address creator;\n        uint32 destParaId;           // Target parachain ID\n        bytes32 sovereignAccount;     // Parachain sovereign account on AssetHub\n        uint256 totalRaised;          // Total USDC raised (after fees)\n        uint256 protocolFeesCollected; // Protocol fees from this campaign\n        bool forwarded;\n        uint256 createdAt;\n    }\n    \n    mapping(uint256 => Campaign) public campaigns;\n    mapping(uint256 => string[]) public campaignMemos;\n    uint256 public nextCampaignId;\n    \n    // Protocol fee configuration (0.1% = 10 basis points)\n    uint256 public constant PROTOCOL_FEE_BPS = 10; // 0.1%\n    uint256 public constant BPS_DENOMINATOR = 10000;\n    \n    // TipsyDot parachain sovereign account for fee collection\n    bytes32 public constant TIPSYDOT_SOVEREIGN = keccak256(\"TipsyDot_Parachain\");\n    uint256 public totalProtocolFeesCollected;\n    uint256 public protocolFeesBalance;\n    \n    // AssetHub USDC precompile on Passet Hub\n    address public constant USDC_PRECOMPILE = address(0x0000000000000000000000000000000000000803); // Example\n    uint32 public constant ASSET_HUB_PARAID = 1000;\n    uint32 public constant TIPSYDOT_PARAID = 3000; // Our parachain ID\n    \n    address public owner;\n    address public treasury; // TipsyDot treasury for coretime costs\n    \n    event CampaignCreated(\n        uint256 indexed campaignId,\n        string name,\n        uint32 destParaId,\n        bytes32 sovereignAccount\n    );\n    \n    event Tipped(\n        uint256 indexed campaignId,\n        address indexed tipper,\n        uint256 grossAmount,\n        uint256 netAmount,\n        uint256 protocolFee,\n        string memo\n    );\n    \n    event ForwardedToSovereign(\n        uint256 indexed campaignId,\n        bytes32 sovereignAccount,\n        uint256 amount,\n        uint32 destParaId\n    );\n    \n    event ProtocolFeesWithdrawn(\n        address indexed to,\n        uint256 amount,\n        string purpose\n    );\n    \n    event CoretimeFunded(\n        uint256 amount,\n        uint256 estimatedDays,\n        string message\n    );\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n    \n    constructor(address _treasury) {\n        owner = msg.sender;\n        treasury = _treasury;\n    }\n    \n    /**\n     * @notice Create a campaign targeting a specific parachain\n     * @param _name Campaign name\n     * @param _description Campaign description\n     * @param _destParaId Target parachain ID\n     * @dev The sovereign account is calculated as the parachain's account on AssetHub\n     */\n    function createCampaign(\n        string memory _name,\n        string memory _description,\n        uint32 _destParaId\n    ) external returns (uint256) {\n        require(bytes(_name).length > 0, \"Name required\");\n        require(_destParaId > 0, \"Invalid parachain ID\");\n        \n        uint256 campaignId = nextCampaignId++;\n        \n        // Calculate parachain sovereign account on AssetHub\n        // In production, this would be the actual sovereign account derivation\n        bytes32 sovereignAccount = keccak256(abi.encodePacked(\"para\", _destParaId));\n        \n        campaigns[campaignId] = Campaign({\n            name: _name,\n            description: _description,\n            creator: msg.sender,\n            destParaId: _destParaId,\n            sovereignAccount: sovereignAccount,\n            totalRaised: 0,\n            protocolFeesCollected: 0,\n            forwarded: false,\n            createdAt: block.timestamp\n        });\n        \n        emit CampaignCreated(campaignId, _name, _destParaId, sovereignAccount);\n        \n        return campaignId;\n    }\n    \n    /**\n     * @notice Tip a campaign with AssetHub USDC (0.1% protocol fee applied)\n     * @param _campaignId Campaign to tip\n     * @param _amount Gross amount of USDC (with decimals)\n     * @param _memo Optional message\n     * @dev Uses AssetHub USDC (Asset ID 1337), deducts 0.1% for coretime costs\n     */\n    function tip(uint256 _campaignId, uint256 _amount, string memory _memo) public {\n        Campaign storage campaign = campaigns[_campaignId];\n        require(campaign.createdAt > 0, \"Campaign not found\");\n        require(!campaign.forwarded, \"Already forwarded\");\n        require(_amount > 0, \"Amount must be > 0\");\n        \n        // Calculate protocol fee (0.1%)\n        uint256 protocolFee = (_amount * PROTOCOL_FEE_BPS) / BPS_DENOMINATOR;\n        uint256 netAmount = _amount - protocolFee;\n        \n        // Transfer AssetHub USDC from tipper to this contract\n        IERC20 usdc = IERC20(USDC_PRECOMPILE);\n        require(\n            usdc.transferFrom(msg.sender, address(this), _amount),\n            \"USDC transfer failed\"\n        );\n        \n        // Update campaign with net amount (after fee)\n        campaign.totalRaised += netAmount;\n        campaign.protocolFeesCollected += protocolFee;\n        \n        // Track total protocol fees\n        protocolFeesBalance += protocolFee;\n        totalProtocolFeesCollected += protocolFee;\n        \n        if (bytes(_memo).length > 0) {\n            campaignMemos[_campaignId].push(_memo);\n        }\n        \n        emit Tipped(_campaignId, msg.sender, _amount, netAmount, protocolFee, _memo);\n    }\n    \n    /**\n     * @notice Forward collected USDC to parachain sovereign account on AssetHub\n     * @param _campaignId Campaign to forward\n     * @dev Sends USDC to the parachain's sovereign account on AssetHub\n     */\n    function forwardToParachain(uint256 _campaignId) public {\n        Campaign storage campaign = campaigns[_campaignId];\n        require(campaign.createdAt > 0, \"Campaign not found\");\n        require(!campaign.forwarded, \"Already forwarded\");\n        require(campaign.totalRaised > 0, \"Nothing to forward\");\n        \n        campaign.forwarded = true;\n        \n        // Send USDC to parachain sovereign account on AssetHub\n        IERC20 usdc = IERC20(USDC_PRECOMPILE);\n        \n        // Transfer to the sovereign account address\n        address sovereignAddress = address(uint160(uint256(campaign.sovereignAccount)));\n        usdc.transfer(sovereignAddress, campaign.totalRaised);\n        \n        emit ForwardedToSovereign(\n            _campaignId,\n            campaign.sovereignAccount,\n            campaign.totalRaised,\n            campaign.destParaId\n        );\n    }\n    \n    /**\n     * @notice Withdraw protocol fees to fund coretime costs\n     * @param _amount Amount to withdraw\n     * @dev Only owner can withdraw to treasury for coretime purchases\n     */\n    function withdrawProtocolFees(uint256 _amount) external onlyOwner {\n        require(_amount <= protocolFeesBalance, \"Insufficient protocol fees\");\n        \n        protocolFeesBalance -= _amount;\n        \n        IERC20 usdc = IERC20(USDC_PRECOMPILE);\n        usdc.transfer(treasury, _amount);\n        \n        emit ProtocolFeesWithdrawn(treasury, _amount, \"Coretime funding\");\n    }\n    \n    /**\n     * @notice Fund parachain coretime on Polkadot relay chain\n     * @param _amount Amount of USDC to allocate for coretime\n     * @dev This demonstrates how protocol fees sustain the parachain\n     */\n    function fundCoretime(uint256 _amount) external onlyOwner {\n        require(_amount <= protocolFeesBalance, \"Insufficient protocol fees\");\n        \n        protocolFeesBalance -= _amount;\n        \n        // In production: Convert USDC to DOT and purchase coretime\n        // For demo: Transfer to TipsyDot parachain sovereign account\n        IERC20 usdc = IERC20(USDC_PRECOMPILE);\n        address tipsydotSovereign = address(uint160(uint256(TIPSYDOT_SOVEREIGN)));\n        usdc.transfer(tipsydotSovereign, _amount);\n        \n        // Estimate coretime coverage (example: 100 USDC = 1 day)\n        uint256 estimatedDays = _amount / (100 * 10**6); // Assuming USDC has 6 decimals\n        \n        emit CoretimeFunded(\n            _amount, \n            estimatedDays,\n            \"Protocol fees funding parachain coretime\"\n        );\n    }\n    \n    /**\n     * @notice View protocol fee statistics\n     */\n    function getProtocolFeeStats() external view returns (\n        uint256 totalCollected,\n        uint256 currentBalance,\n        uint256 feePercentage,\n        uint256 estimatedCoretimeDays\n    ) {\n        uint256 estimatedDays = protocolFeesBalance / (100 * 10**6); // 100 USDC per day estimate\n        \n        return (\n            totalProtocolFeesCollected,\n            protocolFeesBalance,\n            PROTOCOL_FEE_BPS,\n            estimatedDays\n        );\n    }\n    \n    /**\n     * @notice Demonstrates Solidity + XCM: Tip and forward in one transaction\n     */\n    function tipAndForward(\n        uint256 _campaignId,\n        uint256 _amount,\n        string memory _memo\n    ) external {\n        tip(_campaignId, _amount, _memo);\n        forwardToParachain(_campaignId);\n    }\n    \n    /**\n     * @notice Get campaign details including fees\n     */\n    function getCampaignDetails(uint256 _campaignId) external view returns (\n        string memory name,\n        string memory description,\n        address creator,\n        uint32 destParaId,\n        bytes32 sovereignAccount,\n        uint256 totalRaised,\n        uint256 protocolFeesCollected,\n        bool forwarded,\n        uint256 createdAt\n    ) {\n        Campaign memory c = campaigns[_campaignId];\n        return (\n            c.name,\n            c.description,\n            c.creator,\n            c.destParaId,\n            c.sovereignAccount,\n            c.totalRaised,\n            c.protocolFeesCollected,\n            c.forwarded,\n            c.createdAt\n        );\n    }\n    \n    /**\n     * @notice Calculate fee for a given tip amount\n     */\n    function calculateProtocolFee(uint256 _tipAmount) external pure returns (\n        uint256 grossAmount,\n        uint256 protocolFee,\n        uint256 netAmount\n    ) {\n        protocolFee = (_tipAmount * PROTOCOL_FEE_BPS) / BPS_DENOMINATOR;\n        netAmount = _tipAmount - protocolFee;\n        return (_tipAmount, protocolFee, netAmount);\n    }\n    \n    /**\n     * @notice Update treasury address\n     */\n    function setTreasury(address _treasury) external onlyOwner {\n        require(_treasury != address(0), \"Invalid treasury\");\n        treasury = _treasury;\n    }\n}"
      }
    }
  }
}